#!/usr/bin/env bash
# dotfiles - Utility script for managing dotfiles symlinks
# Commands: sync, clean, status, watch
# Version: 1.0.0

set -uo pipefail

# Script version
readonly DOTFILES_VERSION="1.0.0"

# Script directory - find the real location even if symlinked
SCRIPT_PATH="${BASH_SOURCE[0]}"
SCRIPT_DIR="$(cd "$(dirname "$(readlink "$SCRIPT_PATH" || echo "$SCRIPT_PATH")")" && pwd)"
DOTFILES_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# Export key variables for shared libraries
export dot_root="$DOTFILES_ROOT"
export CONFIG_DIR="$DOTFILES_ROOT/config"
export VERBOSE=false

# Source shared libraries
source "$DOTFILES_ROOT/install/lib.sh"
source "$DOTFILES_ROOT/install/symlinks.sh"
source "$DOTFILES_ROOT/install/profiles.sh"

# Configuration
export MANIFEST_FILE="$HOME/.config/.dotfiles-manifest"
export CACHE_FILE="$HOME/.cache/dotfiles-status"
export PROFILE_FILE="$HOME/.config/.dotfiles-profile"

# Detect OS for profile management
detect_os

# Ensure OS_TYPE is exported
export OS_TYPE OS_VERSION

# Get stored profile or default
get_stored_profile() {
  if [[ -f "$PROFILE_FILE" ]]; then
    cat "$PROFILE_FILE"
  else
    echo "minimal"
  fi
}

# Save profile to file
save_profile() {
  local profile="$1"
  echo "$profile" > "$PROFILE_FILE"
}

# Command: sync - Update symlinks using bootstrap
cmd_sync() {
  local profile=""
  local args=()

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -p | --profile | minimal | standard | full | all)
        # Handle both --profile <name> and direct profile name
        if [[ "$1" =~ ^(minimal|standard|full|all)$ ]]; then
          profile="$1"
          shift
        else
          profile="${2:-}"
          shift 2
        fi
        ;;
      *)
        args+=("$1")
        shift
        ;;
    esac
  done

  # Use provided profile or get stored profile
  if [[ -z "$profile" ]]; then
    profile=$(get_stored_profile)
    dot_info "Using stored profile: $profile"
  else
    # Save the new profile
    save_profile "$profile"
  fi

  dot_info "Syncing dotfiles configurations with $profile profile..."
  exec "$DOTFILES_ROOT/bootstrap.sh" --sync --profile "$profile" "${args[@]}"
}

# Command: clean - Remove broken symlinks
cmd_clean() {
  local dry_run=""

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --dry-run | -n)
        dry_run="dry_run"
        export DRY_RUN="$dry_run"
        shift
        ;;
      --verbose | -v)
        export VERBOSE=true
        shift
        ;;
      *)
        shift
        ;;
    esac
  done

  # Use the shared clean_broken_symlinks function
  clean_broken_symlinks "$dry_run"
}

# Command: status - Show symlink health
cmd_status() {
  local show_details=true

  # Check for summary-only flag
  for arg in "$@"; do
    case "$arg" in
      --summary | -s)
        show_details=false
        ;;
    esac
  done

  if [[ "$show_details" == "true" ]]; then
    dot_title "Dotfiles Symlink Status"
  fi

  # Get all config directories
  local config_list
  config_list=$(find "$CONFIG_DIR" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | while read -r dir; do
    basename "$dir" | grep -v '^\.' || true
  done | sort)

  # Check all config directories
  if [[ "$show_details" == "true" ]]; then
    dot_info "Checking configuration symlinks..."
    echo
  fi

  local total_ok=0 total_broken=0 total_missing=0

  # Check config directory symlinks
  while IFS= read -r config; do
    local config_path="$CONFIG_DIR/$config"
    [[ ! -d "$config_path" ]] && continue

    # Show config section only if showing details
    if [[ "$show_details" == "true" ]]; then
      printf "%b%s:%b\n" "$COLOR_HEADER" "$config" "$COLOR_RESET"
    fi

    # Check symlinks for this config
    get_config_symlinks "$config" "$config_path" "$HOME/.config" | while IFS='|' read -r src dest; do
      if [[ "$show_details" == "true" ]]; then
        check_symlink "$src" "$dest" true
      else
        check_symlink "$src" "$dest" false >/dev/null 2>&1
      fi

      # Update counts based on exit status
      local status=$?
      case $status in
        0) ((total_ok++)) || true ;;
        1) ((total_broken++)) || true ;;
        2) ((total_missing++)) || true ;;
      esac
    done

    [[ "$show_details" == "true" ]] && echo
  done <<<"$config_list"

  # Check bin directory symlinks
  if [[ "$show_details" == "true" ]]; then
    printf "%bbin scripts:%b\n" "$COLOR_HEADER" "$COLOR_RESET"
  fi

  # Check each script in bin
  if [[ -d "$DOTFILES_ROOT/bin" ]]; then
    while IFS= read -r script; do
      local script_name
      script_name=$(basename "$script")
      local dest="$HOME/.local/bin/$script_name"

      if [[ "$show_details" == "true" ]]; then
        check_symlink "$script" "$dest" true
      else
        check_symlink "$script" "$dest" false >/dev/null 2>&1
      fi

      # Update counts based on exit status
      local status=$?
      case $status in
        0) ((total_ok++)) || true ;;
        1) ((total_broken++)) || true ;;
        2) ((total_missing++)) || true ;;
      esac
    done < <(find "$DOTFILES_ROOT/bin" -type f -not -name ".*" 2>/dev/null)
    
    [[ "$show_details" == "true" ]] && echo
  fi

  # Summary
  dot_title "Summary"
  print_status "ok" "Correct symlinks: $total_ok"
  print_status "broken" "Broken symlinks: $total_broken"
  print_status "missing" "Missing symlinks: $total_missing"

  if [[ $total_broken -gt 0 ]] || [[ $total_missing -gt 0 ]]; then
    echo
    dot_info "Run 'dotfiles sync' to fix issues"
  fi
}

# Command: watch - Auto-sync on file changes
cmd_watch() {
  dot_title "Watching for Configuration Changes"

  # Check if fswatch is installed
  if ! command -v fswatch &>/dev/null; then
    dot_error "fswatch is not installed"
    dot_info "Install with: brew install fswatch"
    exit 1
  fi

  dot_info "Watching $CONFIG_DIR for changes..."
  dot_info "Press Ctrl+C to stop"
  echo

  # Watch for changes and sync
  fswatch -o "$CONFIG_DIR" | while read -r event; do
    printf "${COLOR_INFO}[%s]${COLOR_RESET} Change detected, syncing...\n" "$(date '+%H:%M:%S')"
    "$DOTFILES_ROOT/bootstrap.sh" --sync --verbose
    echo
  done
}

# Command: profile - Show or change profile
cmd_profile() {
  local new_profile="${1:-}"

  if [[ -z "$new_profile" ]]; then
    # Show current profile
    local current_profile
    current_profile=$(get_stored_profile)

    dot_title "Current Profile"
    echo "  Profile: $current_profile"
    echo "  Description: $(get_profile_description "$current_profile")"
    echo

    # Show available profiles
    dot_title "Available Profiles"
    echo "  minimal   - $(get_profile_description "minimal")"
    echo "  standard  - $(get_profile_description "standard")"
    echo "  full      - $(get_profile_description "full")"
    echo "  all       - $(get_profile_description "all")"
    echo
    dot_info "To switch profiles: dotfiles profile <name>"
  else
    # Validate and switch to new profile
    if validate_profile "$new_profile"; then
      save_profile "$new_profile"
      dot_success "Switched to $new_profile profile"
      dot_info "Run 'dotfiles sync' to apply changes"
    else
      exit 1
    fi
  fi
}

# Show usage
usage() {
  cat <<EOF
Usage: dotfiles <command> [options]

Commands:
    sync,    s       Update symlinks (optional: specify profile)
    profile, p       Show or change current profile
    clean,   c       Remove broken symlinks
    status,  st      Show symlink health and status
    watch,   w       Auto-sync on file changes (requires fswatch)
    help,    h       Show this help message
    version          Show version information

Options:
    -h, --help         Show this help message
    -n, --dry-run      Show what would be done (for clean/sync commands)
    -v, --verbose      Show detailed output (for sync/clean commands)
    -s, --summary      Show summary only (for status command)

Profiles:
    minimal            Essential configs: git, zsh, tmux
    standard           Development tools: minimal + nvim, bat, python
    full               Complete setup: standard + clang-format, lldb, GUI apps
    all                All available configs

Examples:
    dotfiles s                 # Quick sync with current profile
    dotfiles s standard        # Sync with standard profile
    dotfiles s --profile full  # Sync with full profile
    dotfiles p                 # Show current profile
    dotfiles p standard        # Switch to standard profile
    dotfiles st                # Quick status check
    dotfiles st -s             # Summary only
    dotfiles c -n              # Dry-run clean
    dotfiles s -v              # Verbose sync
    dotfiles w                 # Start watching

EOF
  exit 0
}

# Main execution
main() {
  # Check for global help flag first
  for arg in "$@"; do
    case "$arg" in
      -h | --help)
        usage
        ;;
    esac
  done

  local command="${1:-}"
  shift || true

  case "$command" in
    sync | s)
      cmd_sync "$@"
      ;;
    profile | p)
      cmd_profile "$@"
      ;;
    clean | c)
      cmd_clean "$@"
      ;;
    status | st)
      cmd_status "$@"
      ;;
    watch | w)
      cmd_watch "$@"
      ;;
    -h | --help | help | h | "")
      usage
      ;;
    --version | version)
      echo "dotfiles version $DOTFILES_VERSION"
      exit 0
      ;;
    *)
      dot_error "Unknown command: $command"
      usage
      ;;
  esac
}

# Run main function
main "$@"
